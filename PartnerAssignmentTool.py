# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ETj6vu25RMv-foge3NqoLw1n9n9omFI_
"""

import random
import copy

class Student:
    def __init__(self, name, preferences):
        self.name = name
        self.preferences = preferences
        self.partner = None

class PartnershipSolution:
    def __init__(self, students):
        self.students = students
        self.fitness = None

    def get_fitness(self):
        # Return the calculated fitness value
        return self.fitness

    def evaluate_fitness(self):
        # Implement the logic to calculate the fitness of the solution
        # Set the calculated fitness value to self.fitness
        self.fitness = calculate_fitness(self)

    def mutate(self):
        # Implement a mutation operation to explore neighboring solutions
        pass

    def crossover(self, other):
        # Implement a crossover operation to combine two solutions
        pass

    def get_fitness(self):
        # Return the calculated fitness value
        return self.fitness

def load_preferences(file_path):
    students = []
    with open(file_path, 'r') as file:
        for line in file:
            data = line.strip().split(':')
            name = data[0].strip()
            preferences = [p.strip() for p in data[1].split(',') if p.strip()]
            students.append(Student(name, preferences))
    return students

def assign_partners_random(students):
    available_students = copy.deepcopy(students)
    for student in students:
        if available_students:
            partner = random.choice(available_students)
            student.partner = partner.name
            partner.partner = student.name
            available_students.remove(partner)

def calculate_fitness(solution):
    # Implement the logic to calculate the fitness of the solution
    # You can use various criteria based on your problem requirements
    # For example, you can consider preferences, partnerships, etc.
    fitness = 0
    # Your logic to calculate fitness goes here
    return fitness

def create_initial_solution(students):
    # Create an initial partnership solution
    assign_partners_random(students)
    return PartnershipSolution(students)

def apply_optimizer(optimizer, solution, *args, **kwargs):
    return optimizer(solution, *args, **kwargs)


def hill_climbing_optimizer(solution):
    current_solution = solution
    current_fitness = solution.get_fitness()

    while True:
        neighbors = generate_neighbors(current_solution)

        # Filter out neighbors with None fitness
        valid_neighbors = [neighbor for neighbor in neighbors if neighbor.get_fitness() is not None]

        if not valid_neighbors:
            # All neighbors have None fitness, break the loop
            break

        best_neighbor = max(valid_neighbors, key=lambda neighbor: neighbor.get_fitness())

        if best_neighbor.get_fitness() <= current_fitness:
            break  # If the best neighbor doesn't improve fitness, terminate the loop

        current_solution = best_neighbor
        current_fitness = best_neighbor.get_fitness()

    return current_solution


def generate_neighbors(solution):
    # Implement logic to generate neighboring solutions
    # For example, randomly swap partners for a pair of students
    neighbors = []

    for i in range(len(solution.students) // 2):
        neighbor_solution = copy.deepcopy(solution)
        partner1 = neighbor_solution.students[i * 2]
        partner2 = neighbor_solution.students[i * 2 + 1]

        # Swap partners
        partner1.partner, partner2.partner = partner2.name, partner1.name
        neighbor_solution.students[i * 2], neighbor_solution.students[i * 2 + 1] = partner2, partner1

        neighbors.append(neighbor_solution)

    return neighbors

import math
import random

def simulated_annealing_optimizer(initial_solution, initial_temperature, cooling_rate, iterations):
    current_solution = initial_solution
    current_temperature = initial_temperature

    for _ in range(iterations):
        # Generate a neighbor solution
        neighbor_solution2 = generate_neighbor2(current_solution)

        # Check if fitness is available for both current and neighbor solutions
        current_fitness = current_solution.get_fitness()
        neighbor_fitness = neighbor_solution2.get_fitness()

        if current_fitness is not None and neighbor_fitness is not None:
            # Calculate energy (fitness) difference between current and neighbor solutions
            energy_difference = neighbor_fitness - current_fitness

            if energy_difference > 0 or random.uniform(0, 1) < math.exp(energy_difference / current_temperature):
                current_solution = neighbor_solution2

        # Update temperature
        current_temperature *= 1 - cooling_rate

    return current_solution


def generate_neighbor2(solution):
    # Implement logic to generate a neighboring solution
    # For example, randomly swap partners for a pair of students
    neighbor_solution2 = copy.deepcopy(solution)
    i = random.randint(0, len(neighbor_solution2.students) // 2 - 1)

    partner1 = neighbor_solution2.students[i * 2]
    partner2 = neighbor_solution2.students[i * 2 + 1]

    # Swap partners
    partner1.partner, partner2.partner = partner2.name, partner1.name
    neighbor_solution2.students[i * 2], neighbor_solution2.students[i * 2 + 1] = partner2, partner1

    return neighbor_solution2


import random
import copy

def genetic_algorithm_optimizer(initial_solution, population_size, generations, crossover_probability, mutation_probability):
    # Generate an initial population
    population = [generate_random_solution(initial_solution) for _ in range(population_size)]

    for _ in range(generations):
        # Evaluate the fitness of each individual in the population
        for individual in population:
            individual.evaluate_fitness()

        # Filter out individuals with None fitness
        valid_population = [individual for individual in population if individual.get_fitness() is not None]

        # Check if valid_population is empty
        if not valid_population:
            # Handle the case when there are no valid individuals
            # You can return a default solution or take other actions
            return generate_random_solution(initial_solution)

        # Select survivors for the next generation
        population = select_survivors(valid_population, population_size)

    # Return the best solution from the final population
    return max(population, key=lambda ind: ind.get_fitness())

def generate_random_solution(initial_solution):
    # Generate a random solution based on the initial solution
    random_solution = copy.deepcopy(initial_solution)
    random.shuffle(random_solution.students)
    return random_solution

def select_parents(population):
    # Implement parent selection logic
    # For simplicity, let's use random selection for illustration
    return random.sample(population, len(population))

def crossover(parent1, parent2, probability):
    # Implement crossover logic
    # For simplicity, let's use one-point crossover for illustration
    if random.uniform(0, 1) < probability:
        crossover_point = random.randint(1, len(parent1.students) - 1)
        child1 = PartnershipSolution(parent1.students[:crossover_point] + parent2.students[crossover_point:])
        child2 = PartnershipSolution(parent2.students[:crossover_point] + parent1.students[crossover_point:])
        return child1, child2
    else:
        return parent1, parent2

def mutate(solution, probability):
    # Implement mutation logic
    # For simplicity, let's use random swap mutation for illustration
    if random.uniform(0, 1) < probability:
        i, j = random.sample(range(len(solution.students)), 2)
        solution.students[i].partner, solution.students[j].partner = solution.students[j].name, solution.students[i].name
        solution.students[i], solution.students[j] = solution.students[j], solution.students[i]
    return solution

def select_survivors(population, size):
    # Filter out individuals with None fitness
    valid_population = [individual for individual in population if individual.get_fitness() is not None]

    survivors = []
    for _ in range(size):
        if not valid_population:
            break  # Break out of the loop if valid_population is empty
        tournament = random.sample(valid_population, min(3, len(valid_population)))
        winner = max(tournament, key=lambda ind: ind.get_fitness())
        survivors.append(winner)
    return survivors


def calculate_cost(solution):
    cost = 0

    for student in solution.students:
        # Assume the cost increases if a student is not partnered with their preferred partner(s)
        if student.partner not in student.preferences:
            cost += 1

    return cost



def print_partners(students):
    for student in students:
        print(f"{student.name}'s Partner: {student.partner}")

if __name__ == "__main__":
    file_path = "preferences.txt"

    # Step 1: Load preferences data
    students = load_preferences(file_path)
    print("Preferences Data Loaded")

    # Step 2: User chooses optimizer
    print("Choose an optimizer:")
    print("1. Random")
    print("2. Hill Climbing")
    print("3. Simulated Annealing")
    print("4. Genetic")

    choice = input("Enter the number of the optimizer (1-4): ")

    # Step 3: Create an initial solution
    initial_solution = create_initial_solution(students)

    # Step 4: Apply the selected optimizer to the solution
    if choice == "1":
        # No optimization for the random approach, print initial partnerships
        result_solution = initial_solution  # Set result_solution to the initial solution
    elif choice == "2":
        # Apply Hill Climbing optimization
        apply_optimizer(hill_climbing_optimizer, initial_solution)
        result_solution = initial_solution
    elif choice == "3":
        # Apply Simulated Annealing optimization
        result_solution = apply_optimizer(simulated_annealing_optimizer, initial_solution, initial_temperature, cooling_rate, iterations)
    elif choice == "4":
        # Apply Genetic Algorithm optimization
        population_size = 100
        generations = 50
        crossover_probability = 0.8
        mutation_probability = 0.2

        result_solution = apply_optimizer(genetic_algorithm_optimizer, initial_solution, population_size, generations, crossover_probability, mutation_probability)
    else:
        print("Invalid choice. Please enter a number between 1 and 4.")
        sys.exit()

    # Step 5: Print the results
    print("Optimized Partnerships:")
    print_partners(result_solution.students)

    # Calculate and display the total cost
    total_cost = calculate_cost(result_solution)
    print(f"Total Cost: {total_cost}")